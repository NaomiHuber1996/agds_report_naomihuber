---
title: "agds_report_10"
author: "Naomi Huber"
date: "2023-05-15"
output: html_document
---

#### Reading in the data ecosystem flux data

Loading the data of Davos:

```{r}
library(lubridate)
library(dplyr)
library(readr)

daily_fluxes_davos <- read_csv("https://raw.githubusercontent.com/geco-bern/agds/main/data/FLX_CH-Dav_FLUXNET2015_FULLSET_DD_1997-2014_1-3.csv") |>  
  
  # select only the variables we are interested in
  dplyr::select(TIMESTAMP,
                GPP_NT_VUT_REF,    # the target
                ends_with("_QC"),  # quality control info
                ends_with("_F"),   # includes all all meteorological covariates
                -contains("JSB")   # weird useless variable
  ) |>
  
  # convert to a nice date object
  dplyr::mutate(TIMESTAMP = ymd(TIMESTAMP)) |>
  
  # set all -9999 to NA
  mutate(across(where(is.numeric), ~na_if(., -9999))) |>
  
  # and retain only data based on >=80% good-quality measurements
  # overwrite bad data with NA (not dropping rows)
  dplyr::mutate(GPP_NT_VUT_REF = ifelse(NEE_VUT_REF_QC < 0.8, NA, GPP_NT_VUT_REF),
                TA_F           = ifelse(TA_F_QC        < 0.8, NA, TA_F),
                SW_IN_F        = ifelse(SW_IN_F_QC     < 0.8, NA, SW_IN_F),
                LW_IN_F        = ifelse(LW_IN_F_QC     < 0.8, NA, LW_IN_F),
                VPD_F          = ifelse(VPD_F_QC       < 0.8, NA, VPD_F),
                PA_F           = ifelse(PA_F_QC        < 0.8, NA, PA_F),
                P_F            = ifelse(P_F_QC         < 0.8, NA, P_F),
                WS_F           = ifelse(WS_F_QC        < 0.8, NA, WS_F)) |> 
  
  # drop QC variables
  dplyr::select(-ends_with("_QC"))

# remove P_F
daily_fluxes_davos <- subset(daily_fluxes_davos, select = -P_F)
```

Loading the data of Laegern:

```{r}
daily_fluxes_laegern <- read_csv("https://raw.githubusercontent.com/geco-bern/agds/main/data/FLX_CH-Lae_FLUXNET2015_FULLSET_DD_2004-2014_1-4.csv") |>

# select only the variables we are interested in
  dplyr::select(TIMESTAMP,
                GPP_NT_VUT_REF,    # the target
                ends_with("_QC"),  # quality control info
                ends_with("_F"),   # includes all all meteorological covariates
                -contains("JSB")   # weird useless variable
  ) |>
  
  # convert to a nice date object
  dplyr::mutate(TIMESTAMP = ymd(TIMESTAMP)) |>
  
  # set all -9999 to NA
  mutate(across(where(is.numeric), ~na_if(., -9999))) |>
  
  # and retain only data based on >=80% good-quality measurements
  # overwrite bad data with NA (not dropping rows)
  dplyr::mutate(GPP_NT_VUT_REF = ifelse(NEE_VUT_REF_QC < 0.8, NA, GPP_NT_VUT_REF),
                TA_F           = ifelse(TA_F_QC        < 0.8, NA, TA_F),
                SW_IN_F        = ifelse(SW_IN_F_QC     < 0.8, NA, SW_IN_F),
                LW_IN_F        = ifelse(LW_IN_F_QC     < 0.8, NA, LW_IN_F),
                VPD_F          = ifelse(VPD_F_QC       < 0.8, NA, VPD_F),
                PA_F           = ifelse(PA_F_QC        < 0.8, NA, PA_F),
                P_F            = ifelse(P_F_QC         < 0.8, NA, P_F),
                WS_F           = ifelse(WS_F_QC        < 0.8, NA, WS_F)) |> 
  
  # drop QC variables
  dplyr::select(-ends_with("_QC"))

# remove P_F
daily_fluxes_laegern <- subset(daily_fluxes_laegern, select = -P_F)
```

Merging the data of Davos and Laegern:

```{r}
daily_fluxes_davos$type <- "dav"
daily_fluxes_laegern$type <- "lae"
merged_data <- rbind(daily_fluxes_davos, daily_fluxes_laegern)
```

#### Splitting the data Set aside 20% of the data of Davos:

```{r}
set.seed(123)
split <- rsample::initial_split(daily_fluxes_davos, prop = 0.8, strata = "VPD_F")
daily_fluxes_dav_train <- rsample::training(split)
daily_fluxes_dav_test <- rsample::testing(split)
```

Set aside 20% of the data of Laegern:

```{r}
set.seed(123)
split <- rsample::initial_split(daily_fluxes_laegern, prop = 0.8, strata = "VPD_F")
daily_fluxes_lae_train <- rsample::training(split)
daily_fluxes_lae_test <- rsample::testing(split)

```

Set aside 20% of the data of both sites:

```{r}
set.seed(123)
split <- rsample::initial_split(merged_data, prop = 0.8, strata = "VPD_F")
merged_data_train <- rsample::training(split)
merged_data_test <- rsample::testing(split)
```

#### Comparison within-site and across-site predictions Davos:

```{r}
library(tidyverse)
library(caret)

pp_dav <- recipes::recipe(GPP_NT_VUT_REF ~ SW_IN_F + VPD_F + TA_F, 
                      data = daily_fluxes_dav_train |> drop_na()) |> 
  #recipes::step_BoxCox(all_predictors()) |> 
  recipes::step_center(all_numeric(), -all_outcomes()) |>
  recipes::step_scale(all_numeric(), -all_outcomes())
```

Laegern:

```{r}
library(tidyverse)
library(caret)

pp_lae <- recipes::recipe(GPP_NT_VUT_REF ~ SW_IN_F + VPD_F + TA_F, 
                      data = daily_fluxes_lae_train |> drop_na()) |> 
  #recipes::step_BoxCox(all_predictors()) |> 
  recipes::step_center(all_numeric(), -all_outcomes()) |>
  recipes::step_scale(all_numeric(), -all_outcomes())
```

Merged:

```{r}
library(tidyverse)
library(caret)

pp_merged <- recipes::recipe(GPP_NT_VUT_REF ~ SW_IN_F + VPD_F + TA_F, 
                      data = merged_data_train |> drop_na()) |> 
  #recipes::step_BoxCox(all_predictors()) |> 
  recipes::step_center(all_numeric(), -all_outcomes()) |>
  recipes::step_scale(all_numeric(), -all_outcomes())
```

#### KNN-model with k = 8 Davos:

```{r}
library(recipes)

mod_knn_dav <- caret::train(
  pp_dav, 
  data = daily_fluxes_dav_train |> drop_na(), 
  method = "knn",
  trControl = caret::trainControl(method = "cv"),
  tuneGrid = data.frame(k = 8),
  metric = "RMSE"
)
```

Laegern:

```{r}
library(recipes)

mod_knn_lae <- caret::train(
  pp_lae, 
  data = daily_fluxes_lae_train |> drop_na(), 
  method = "knn",
  trControl = caret::trainControl(method = "cv"),
  tuneGrid = data.frame(k = 8),
  metric = "RMSE"
)
```

Merged:

```{r}
library(recipes)

mod_knn_merged <- caret::train(
  pp_merged, 
  data = merged_data_train |> drop_na(),
  method = "knn",
  trControl = caret::trainControl(method = "cv"),
  tuneGrid = data.frame(k = 8),
  metric = "RMSE"
)
```

#### Find the optimal k Davos:

```{r}
library(recipes)

# definition of the k-values
k_values_davos <- seq(1, 50, by = 1)

# empty vector for RMSE-values of each k
rmse_values <- rep(NA, length(k_values_davos))

# iteration over k with shaping the training data
for (i in seq_along(k_values_davos)) {
  k <- k_values_davos[i]
  mod_knn <- caret::train(
    pp_dav, 
    data = daily_fluxes_dav_train |> drop_na(), 
    method = "knn",
    trControl = caret::trainControl(method = "cv"),
    tuneGrid = data.frame(k = k),
    metric = "RMSE"
  )
  # saving the RMSE-values for each k
  rmse_values[i] <- mod_knn$results$RMSE
}

# choosing the best k with the best RMSE-value (smallest)
best_k_davos <- k_values_davos[which.min(rmse_values)]
best_k_davos
```

Laegern:

```{r}
library(recipes)

# definition of the k-values
k_values_laegern <- seq(1, 50, by = 1)

# empty vector for RMSE-values of each k
rmse_values <- rep(NA, length(k_values_laegern))

# iteration over k with shaping the training data
for (i in seq_along(k_values_laegern)) {
  k <- k_values_laegern[i]
  mod_knn <- caret::train(
    pp_lae, 
    data = daily_fluxes_lae_train |> drop_na(), 
    method = "knn",
    trControl = caret::trainControl(method = "cv"),
    tuneGrid = data.frame(k = k),
    metric = "RMSE"
  )
  # saving the RMSE-values for each k
  rmse_values[i] <- mod_knn$results$RMSE
}

# choosing the best k with the best RMSE-value (smallest)
best_k_laegern <- k_values_laegern[which.min(rmse_values)]
best_k_laegern

```

Both locations:
```{r}
library(recipes)

# definition of the k-values
k_values_merged <- seq(1, 50, by = 1)

# empty vector for RMSE-values of each k
rmse_values <- rep(NA, length(k_values_merged))

# iteration over k with shaping the training data
for (i in seq_along(k_values_merged)) {
  k <- k_values_merged[i]
  mod_knn <- caret::train(
    pp_merged, 
    data = merged_data_train |> drop_na(), 
    method = "knn",
    trControl = caret::trainControl(method = "cv"),
    tuneGrid = data.frame(k = k),
    metric = "RMSE"
  )
  # saving the RMSE-values for each k
  rmse_values[i] <- mod_knn$results$RMSE
}

# choosing the best k with the best RMSE-value (smallest)
best_k_merged <- k_values_merged[which.min(rmse_values)]
best_k_merged
```

#### Calculation all of the KNN-models with their optimal k:

Davos:

```{r}
library(recipes)

mod_knn_dav <- caret::train(
  pp_dav, 
  data = daily_fluxes_dav_train |> drop_na(), 
  method = "knn",
  trControl = caret::trainControl(method = "cv"),
  tuneGrid = data.frame(k = best_k_davos),
  metric = "RMSE"
)
```

Laegern:

```{r}
library(recipes)

mod_knn_lae <- caret::train(
  pp_lae, 
  data = daily_fluxes_lae_train |> drop_na(), 
  method = "knn",
  trControl = caret::trainControl(method = "cv"),
  tuneGrid = data.frame(k = best_k_laegern),
  metric = "RMSE"
)
```

Both locations:

```{r}
library(recipes)

mod_knn_merged <- caret::train(
  pp_merged, 
  data = merged_data_train |> drop_na(), 
  method = "knn",
  trControl = caret::trainControl(method = "cv"),
  tuneGrid = data.frame(k = best_k_merged),
  metric = "RMSE"
)
```

#### Plot of the optimal models

```{r}
source("https://raw.githubusercontent.com/NaomiHuber1996/agds_report_naomihuber/main/vignettes/re_ml_01_functions/function_evalmodel.R")
```

```{r}
library(ggplot2)
library(tidyr)
library(cowplot)

# KNN_Davos
p1 <- eval_model(mod = mod_knn_dav, df_train = daily_fluxes_dav_train, df_test = daily_fluxes_dav_test, c("Davos"), c("Davos"))
p1.1 <- eval_model(mod = mod_knn_dav, df_train = daily_fluxes_dav_train, df_test = daily_fluxes_lae_test, c("Davos"), c("Laegern"))
p1.2 <- eval_model(mod = mod_knn_dav, df_train = daily_fluxes_dav_train, df_test = merged_data_test, c("Davos"), c("Merged"))

# KNN_Laegern
p2 <- eval_model(mod = mod_knn_lae, df_train = daily_fluxes_lae_train, df_test = daily_fluxes_lae_test, c("Laegern"), c("Laegern"))
p2.1 <- eval_model(mod = mod_knn_lae, df_train = daily_fluxes_lae_train, df_test = daily_fluxes_dav_test, c("Laegern"), c("Davos"))
p2.2 <- eval_model(mod = mod_knn_lae, df_train = daily_fluxes_lae_train, df_test = merged_data_test, c("Laegern"), c("Merged"))

# KNN_merged
p3 <- eval_model(mod = mod_knn_merged, df_train = merged_data_train, df_test = merged_data_test, c("Merged"), c("Merged"))
p3.1 <- eval_model(mod = mod_knn_merged, df_train = merged_data_train, df_test = daily_fluxes_dav_test, c("Merged"), c("Davos"))
p3.2 <- eval_model(mod = mod_knn_merged, df_train = merged_data_train, df_test = daily_fluxes_lae_test, c("Merged"), c("Laegern"))

# Create a cowplot for better interpretation
plot_grid(p1, p2, p3, ncol = 1, nrow = 3)
```

```{r}
# Create a cowplot which shows the training data of Davos in the column on the left and the three test data in the column right
plot_grid(p1, p1.1, p1.2, ncol = 1, nrow = 3) #visualisation of the comparison between the Davos training set and the different test set
plot_grid(p2, p2.1, p2.2, ncol = 1, nrow = 3) #visualisation of the comparison between the Laegern training set and the different test set
plot_grid(p3, p3.1, p3.2, ncol = 1, nrwo = 3) #visualisation of the comparison between the merged training set and the different test se
```

#### Get information about the characteristics of the two sites. What are the differences in terms of climate, vegetation, altitude, etc. between the Davos and Laegern sites? Interpret biases of the out-of-sample predictions with a view to the site characteristics.
Regarding the different sites, Davos records an altitude of about 1.5km whereas Laegern is of about 800m high. Therefore, the climate in Davos is more alpin than in Laegern, where it is mosty moderate. Furthermore, in Davos it has more alpine vegetation whereas in Laegern is not only grassland but also forests which influence the GPP-value a lot. If we look at the calculated data, we can assume that the comparison between the location Davos and Laegern is not ideal, because they are shaped by different characteristics. It is obvious, that the Davos test data fits best with the Davos trainigs data (RMSE-value of 1.52, which is compared to the other ones the smallest one). The test data Laegern provides the badest RMSE-value (3.41) which supports the assumption mentioned above. Regarding the Laegern trainings data compared with the different test data, we recognize that as well the test and trainings data of Laegern match the best. But the other test data provide a more close RMSE-value compared to the data of Davos.
